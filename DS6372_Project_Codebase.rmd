---
title: "MSDS-6372-Project2"
author: "Holmes, Karki, Webb"
date: '11/12/2022'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Set-up
__Libraries__
```{r load-packages, include=FALSE}
## Source - https://statsandr.com/blog/an-efficient-way-to-install-and-load-r-packages/
# Package names
packages <- c("aplore3", "tidyverse", "corrplot", "car", "caTools", "ROCR", "caret", "naniar", "GGally", "rgl")

# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())

if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Packages loading
invisible(lapply(packages, library, character.only = TRUE))
```

```{r echo=FALSE}
packages
```
__Data Import__
```{r}
df <- glow_bonemed
summary(df) ## ratio of response (fracture) is 3:1 No to Yes
str(df)
gg_miss_var(df) ## no missing data

# New column for numeric fracture
df$frac_num <- ifelse(df$fracture == "Yes", 1, 0)
table(df$frac_num, df$fracture)

# New data frames for Numeric and Categorical
num_df <-
  df %>%
  select(is.numeric)
str(num_df)

cat_df <-
  df %>%
  select_if(negate(is.numeric))
str(cat_df)

# Variable Analysis
df %>%
  select(fracture) %>%
  group_by(fracture) %>%
  summarize(count = n()) %>%
  mutate(percent = count / sum(count))
```

__EDA__
```{r}
# Numeric Variables
df %>%
  ggplot(aes(x = age, y = frac_num)) +
  geom_point() +
  geom_smooth(formula = y ~ x, method = "loess", span = .8) +
  ggtitle("Age vs Fracture")

df %>%
  ggplot(aes(x = weight, y = frac_num)) +
  geom_point() +
  geom_smooth(formula = y ~ x, method = "loess", span = .8) +
  ggtitle("Weight vs Fracture")

df %>%
  ggplot(aes(x = height, y = frac_num)) +
  geom_point() +
  geom_smooth(formula = y ~ x, method = "loess", span = .8) +
  ggtitle("Height vs Fracture")

df %>%
  ggplot(aes(x = bmi, y = frac_num)) +
  geom_point() +
  geom_smooth(formula = y ~ x, method = "loess", span = .8) +
  ggtitle("BMI vs Fracture")

df %>%
  ggplot(aes(x = fracscore, y = frac_num)) +
  geom_point() +
  geom_smooth(formula = y ~ x, method = "loess", span = .8) +
  ggtitle("Fracscore vs Fracture")

# Correlation
M <- cor(num_df[, 1:8])
corrplot.mixed(M, lower = 'number', upper = 'ellipse', order = 'alphabet')

model <- lm(frac_num ~ ., data = df[, -c(15)])
vif(model)

df %>%
  ggplot(aes(x = height, y = fracscore, color = fracture)) +
  geom_point()

# This is to output a rgl plot in a rmarkdown document.
setupKnitr()

# Data: the iris data is provided by R

# Add a new column with color
mycolors <- c('blue', 'red')
df$color <- mycolors[ as.numeric(df$fracture) ]

# Plot
plot3d( 
  x=df$phy_id, y=df$age, z=df$weight, 
  col = df$color, 
  type = 's', 
  radius = 1,
  xlab="Phys", ylab="Height", zlab="Weight")
```

```{r}
# Categorical Variables
g1 <-
  df %>%
  group_by(fracture, priorfrac) %>%
  summarise(cnt = n()) %>%
  mutate(perc = round(cnt / sum(cnt), 4)) %>%
  arrange(desc(perc))
g1

g1[c(2, 3), ] %>%
  ggplot(aes(x = reorder(priorfrac, -perc), y = perc, color = priorfrac)) +
  geom_bar(aes(fill = priorfrac), stat = "identity") +
  xlab("Prior Fracture") +
  ylab("Proportion")

g2 <-
  df %>%
  group_by(fracture, premeno) %>%
  summarise(cnt = n()) %>%
  mutate(perc = round(cnt / sum(cnt), 4)) %>%
  arrange(desc(perc))
g2

g2[c(2, 3), ] %>%
  ggplot(aes(x = reorder(premeno, -perc), y = perc, color = premeno)) +
  geom_bar(aes(fill = premeno), stat = "identity") +
  xlab("Premeno") +
  ylab("Proportion")

g3 <-
  df %>%
  group_by(fracture, momfrac) %>%
  summarise(cnt = n()) %>%
  mutate(perc = round(cnt / sum(cnt), 4)) %>%
  arrange(desc(perc))
  ylab("Proportion")
g3

g3[c(2, 3), ] %>%
  ggplot(aes(x = reorder(momfrac, -perc), y = perc, color = momfrac)) +
  geom_bar(aes(fill = momfrac), stat = "identity") +
  xlab("Momfrac") +
  ylab("Proportion")

g4 <-
  df %>%
  group_by(fracture, armassist) %>%
  summarise(cnt = n()) %>%
  mutate(perc = round(cnt / sum(cnt), 4)) %>%
  arrange(desc(perc))
g4

g4[c(2, 3), ] %>%
  ggplot(aes(x = reorder(armassist, -perc), y = perc, color = armassist)) +
  geom_bar(aes(fill = armassist), stat = "identity") +
  xlab("Armassist") +
  ylab("Proportion")


g5 <-
  df %>%
  group_by(fracture, smoke) %>%
  summarise(cnt = n()) %>%
  mutate(perc = round(cnt / sum(cnt), 4)) %>%
  arrange(desc(perc))
g5

g5[c(1, 4), ] %>%
  ggplot(aes(x = reorder(smoke, -perc), y = perc, color = smoke)) +
  geom_bar(aes(fill = smoke), stat = "identity") +
  xlab("Smoke") +
  ylab("Proportion")

g6 <-
  df %>%
  group_by(fracture, raterisk) %>%
  summarise(cnt = n()) %>%
  mutate(perc = round(cnt / sum(cnt), 4)) %>%
  arrange(desc(perc))
g6

g6[c(1, 2, 6), ] %>%
  ggplot(aes(x = reorder(raterisk, -perc), y = perc, color = raterisk)) +
  geom_bar(aes(fill = raterisk), stat = "identity") +
  xlab("Raterisk") +
  ylab("Proportion")

g7 <-
  df %>%
  group_by(fracture, bonemed) %>%
  summarise(cnt = n()) %>%
  mutate(perc = round(cnt / sum(cnt), 4)) %>%
  arrange(desc(perc))
g7

g7[c(2, 3), ] %>%
  ggplot(aes(x = reorder(bonemed, -perc), y = perc, color = bonemed)) +
  geom_bar(aes(fill = bonemed), stat = "identity") +
  xlab("Bonemed") +
  ylab("Proportion")

g8 <-
  df %>%
  group_by(fracture, bonemed_fu) %>%
  summarise(cnt = n()) %>%
  mutate(perc = round(cnt / sum(cnt), 4)) %>%
  arrange(desc(perc))
g8

g8[c(2, 3), ] %>%
  ggplot(aes(x = reorder(bonemed_fu, -perc), y = perc, color = bonemed_fu)) +
  geom_bar(aes(fill = bonemed_fu), stat = "identity") +
  xlab("Bonemed_fu") +
  ylab("Proportion")

g8 <-
  df %>%
  group_by(fracture, bonetreat) %>%
  summarise(cnt = n()) %>%
  mutate(perc = round(cnt / sum(cnt), 4)) %>%
  arrange(desc(perc))
g8

g8[c(2, 3), ] %>%
  ggplot(aes(x = reorder(bonetreat, -perc), y = perc, color = bonetreat)) +
  geom_bar(aes(fill = bonetreat), stat = "identity") +
  xlab("Bonetreat") +
  ylab("Proportion")
```

__Train, Test, Validation Split__
```{r}
set.seed(123)
# Split data into smaller sets: 80% training, 10% test, and 10% validate
ss <- sample(1:3, size = nrow(df), replace = TRUE, prob = c(0.8, 0.2))
train <- df[ss == 1, ]
test <- df[ss == 2, ]
```

### Objective 1
Display the ability to perform EDA and build a logistic regression model for interpretation purposes.
__Simple Logistic Regression__
```{r}
# Removing BMI, Age, and Site ID due to multicollinearity
train_sub <-
  train %>%
  select(-c("sub_id", "bmi", "age", "site_id", "frac_num", "smoke"))

# Logistic Model
log_model <- glm(fracture ~ ., data = train_sub, family = "binomial")
coef(summary(log_model))

glm_back <- step(log_model, direction = "backward")
glm_fwd <- step(log_model, direction = "forward")
glm_both <- step(log_model, direction = "both")

summary(glm_back)
glm_back$deviance
AIC(glm_back)
BIC(glm_back)

summary(glm_fwd)
glm_fwd$deviance
AIC(glm_fwd)
BIC(glm_fwd)

summary(glm_both)
glm_both$deviance
AIC(glm_both)
BIC(glm_both)

glm_both$coefficients

# Final Model
log_model <-
  glm(fracture ~ priorfrac + height + momfrac + fracscore + bonemed_fu + bonetreat,
  data = train_sub, family = "binomial")
summary(log_model)

# Predict test data based on model
predict_test <- predict(log_model, test, type = "response")
predict_val <- predict(log_model, valid, type = "response")

# Changing probabilities
predict_test_fact <- ifelse(predict_test > 0.3, "Yes", "No")
predict_val_fact <- ifelse(predict_val > 0.3, "Yes", "No")

   
# Model Performance
confusionMatrix(data = as.factor(predict_test_fact), reference = test$fracture)
confusionMatrix(data = as.factor(predict_val_fact), reference = valid$fracture)


# ROC-AUC Curve
ROCPred <- prediction(predict_test, test$fracture) 
ROCPer <- performance(ROCPred, measure = "tpr", x.measure = "fpr")
   
auc <- performance(ROCPred, measure = "auc")
auc <- auc@y.values[[1]]
auc
   
# Plotting curve
plot(ROCPer)
plot(ROCPer, colorize = TRUE, 
     print.cutoffs.at = seq(0.1, by = 0.1), 
     main = "ROC CURVE")
abline(a = 0, b = 1)
   
auc <- round(auc, 4)
legend(.6, .4, auc, title = "AUC", cex = 1)
```

### Objective 2
With a simple logistic regression model as a baseline, perform additional competing models to improve on prediction performance metrics.
__Complex Logistic Regression__
```{r}

```

__LDA/QDA__ ## only on numeric variables
```{r}
lda_train <- train[, c("age", "weight", "height", "bmi", "fracscore", "fracture")]
lda_test <- test[, c("age", "weight", "height", "bmi", "fracscore", "fracture")]
lda_valid <- valid[, c("age", "weight", "height", "bmi", "fracscore", "fracture")]
##View(dflda)
ggpairs(lda_train, aes(color = fracture))
```


```{r}
fitControl<-trainControl(method="repeatedcv",number=5,repeats=1,classProbs=TRUE, summaryFunction=mnLogLoss)

lda.fit <- train(fracture ~ .,
  data = lda_train,
  method = "lda",
  trControl = fitControl,
  metric = "logLoss"
)
lda.fit

qda.fit <- train(fracture ~ .,
  data = lda_train,
  method = "qda",
  trControl = fitControl,
  metric = "logLoss"
)

qda.fit

knn.fit <- train(fracture ~ .,
  data = lda_train,
  method = "knn",
  trControl = fitControl,
  tuneGrid = data.frame(k = c(1, 5, 10, 15, 25, 50, 100, 200, 300, 400)),
  metric = "logLoss"
)

knn.fit

plot(knn.fit)

```


```{r}
predictions <- data.frame(status = lda_valid$fracture)
predictions$knn <- predict(knn.fit, lda_valid, type = "prob")[, "No"]
predictions$LDA <- predict(lda.fit, lda_valid, type = "prob")[, "No"]
predictions$QDA <- predict(qda.fit, lda_valid, type = "prob")[, "No"]
View(predictions)
```


__KNN__

```{r}
# See how many women fractured a bone within the first year after joining the study
table(df$fracture)
```



```{r}
# Look at data
df
# Look at datatypes 
str(df)

# Make a copy of original data as a working copy
df1 <- df

# one hot encode for categorical variables
df1$priorfrac<-ifelse(df1$priorfrac=='Yes', 1, 0)
df1$premeno<-ifelse(df1$premeno=='Yes', 1, 0)
df1$momfrac<-ifelse(df1$momfrac=='Yes', 1, 0)
df1$armassist<-ifelse(df1$armassist=='Yes', 1, 0)
df1$smoke<-ifelse(df1$smoke=='Yes', 1, 0)
df1$fracture<-ifelse(df1$fracture=='Yes', 1, 0)
df1$bonemed<-ifelse(df1$bonemed=='Yes', 1, 0)
df1$bonemed_fu<-ifelse(df1$bonemed_fu=='Yes', 1, 0)
df1$bonetreat<-ifelse(df1$bonetreat=='Yes', 1, 0)
df1$raterisk<-as.numeric(factor(df1$raterisk))

# check the data
df1

```



```{r}
# delete columns that probably wont help predict
df1 <- df1[-c(1, 2, 3)]
# check data
df1

# standardize function
standardize <- function(x) {
  return ((x - min(x)) / (max(x) - min(x)))
}

# standardize the data
df1.subset.n<- as.data.frame(lapply(df1[, c(-12)], standardize))

# Check data
head(df1.subset.n)


```


```{r}

set.seed(123)

# Random selection of 70% data.
dat.d <- sample(1:nrow(df1.subset.n), size=nrow(df1.subset.n)*0.7, replace = FALSE) 

# 70% training data
train.bone <- df1[dat.d, ] 
# Remaining 30% test data
test.bone <- df1[-dat.d, ] 

# Create a separate dataframe for "Fractured?" feature, which is our target.
train.bone_labels <- df1[dat.d, 12]
test.bone_labels  <- df1[-dat.d, 12] 


```


```{r}
# To find the number of observation
NROW(train.bone_labels)

# sqrt of obs is decent k
sqrt(NROW(train.bone_labels))

```


```{r}
# Run knn for 18 & 19
knn.18 <-  knn(train=train.bone, test=test.bone, cl=train.bone_labels, k=18)
knn.19 <-  knn(train=train.bone, test=test.bone, cl=train.bone_labels, k=19)

# Accuracy score for knn 18 & 19
ACC.18 <- 100 * sum(test.bone_labels == knn.18)/NROW(test.bone_labels)
ACC.19 <- 100 * sum(test.bone_labels == knn.19)/NROW(test.bone_labels)
ACC.18
ACC.19

# to check prediction against actual value in tabular form
table(knn.18, test.bone_labels) 
table(knn.19, test.bone_labels) 

# Zero means no and one means yes to fracture
# looking at not fractured as positive class

# Make factors so we can do confusion matrix
test.bone_labels <- factor(test.bone_labels)
# Create confusion matrix
confusionMatrix(knn.18, test.bone_labels)


```


```{r}
# declaration to initiate for loop
i=1                          
k.optm=1                    

# For loop for accuracy scores
for (i in 1:25){ 
    knn.mod <-  knn(train=train.bone, test=test.bone, cl=train.bone_labels, k=i)
    k.optm[i] <- 100 * sum(test.bone_labels == knn.mod)/NROW(test.bone_labels)
    k=i  
    cat(k, '=', k.optm[i], '\n')   
}

# Plot accuracy for different k
plot(k.optm, type='b', xlab='K-Value', ylab='Accuracy level')


```






